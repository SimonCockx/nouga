/****** Start of DSL research ******/

// Type-checking test FIXED??
func FuncTypeCheckTest:
	output: result boolean (1..1)
	assign-output result:
		1.0

func MultiOrTest:
	output: result boolean (0..*)
	assign-output result:
		[True, False] or True

func MultiArithmetic:
	output: result number (0..*)

	assign-output result:
		[0, 1] / [5, 8, 9] - [3, 4] * 9

type Supertype:
	val number (1..5)

type Subtype extends Supertype:
	override val int (1..5)

type ListOfNumbers:
	list number (0..*)
func AssignSomeNumber:
	output: list ListOfNumbers (1..1)
	assign-output list->list[25]:
		5.0

// func ContainsTest:
// 	output: result boolean (1..1)
// 	assign-output result:
// 		[[True, True], False]

func SomeFunction:
  output:
    result number (0..1)
  assign-output result:
    if True then 0 else empty

type Parent:
type Child1 extends Parent:
type Child2 extends Parent:

func CreateChild1:
	output: result Child1 (1..1)
func CreateChild2:
	output: result Child2 (1..1)

func CreateParentList:
	output: result Parent (0..*)
	assign-output result:
		[CreateChild1(), CreateChild2()]


func CardTest:
	output: result int (2..2)
	assign-output result:
		[1]

// Syntax testing
// func OnlyExistsTest:
// 	inputs: inp Supertype (1..1)
// 	output: result boolean (1..1)
// 	assign-output result:
// 		Supertype only exists

// func IndexInputTest:
// 	inputs: list int (0..*)
// 	output: result int (1..1)
// 	assign-output result:
// 		list[0]

func MultiOutputTest:
	output: result int (2..2)
	assign-output result:
		[0, 0]

type Container:
	val int (1..1)
func GroupByTest:
	inputs: list Container (0..*)
	output: result int (1..1)
	assign-output result:
		list group by val count

func AttrCallTest: // FIXED?
	inputs:
		p Period (1..1)
	output:
		r int (1..1)
	
	assign-output r:
		p->only-element

func Empty:

func CallableCallTest:
	output: result int (1..1)
	assign-output result:
		CardTest

func ContainsTest:
	inputs: list boolean (0..*)
	output: result boolean (1..1)
	assign-output result:
		list contains 5

type Period:
	frequency int (1..1)
	periodEnum MyPeriodEnum (1..1)
	period number (1..1)

enum MyPeriodEnum:
	Month

func DayFraction :
	inputs: in2 Period( 1..1 )
	output: res number (1..1)
	alias p: PeriodEnumFunc(in2 -> periodEnum, in2)
	assign-output res: p / 360
	
func PeriodEnumFunc :
	inputs:
		in1 MyPeriodEnum( 1..1 )
			in2 Period( 1..1 )
	output: out number( 1..1 )

func PeriodEnumFunc(in1: MyPeriodEnum -> Month ):
	alias i: in2 -> frequency
	assign-output out: i * 30.0

func Test:

type Inner:
	val number (1..1)
type NestedType:
	inner Inner (1..2)
func PathTest:
	output: result NestedType (2..2)
	assign-output result->inner[1]->val:
		5
	assign-output result->inner->val:
		5

type EmptyCard:
	zero number (0..0)


// Contract DSL

enum CurrencyEnum:
	EUR
	GBP
	USD

type ConstObservable:
	val number (1..1)

type TimeObservable:
	time date (1..1)

type Observable:
	constObs ConstObservable (0..1)
	time TimeObservable (0..1)

	condition: one-of

func Observe:
	inputs:
		observable Observable (1..1)
		time date (1..1)
	output:
		result number (1..1)
	
	assign-output result:
		if observable->constObs exists then observable->constObs->val
		else if observable->time exists then DateDifference(observable->time->time, time)


type Horizon: <"Represents the horizon of a contract. If `time` is absent, then this should be interpreted as an infinite horizon.">
	time date (0..1)

func CreateHorizon:
	inputs:
		time date (1..1)
	output:
		result Horizon (1..1)
	
	assign-output result->time:
		time

func InfiniteHorizon:
	output:
		result Horizon (1..1)
	
	assign-output result->time:
		empty

func LastHorizon:
	inputs:
		horizon1 Horizon (1..1)
		horizon2 Horizon (1..1)
	output:
		result Horizon (1..1)

	assign-output result:
		if horizon1->time exists and horizon2->time exists then (
			if horizon1->time > horizon2->time
			then horizon1
			else horizon2)
		else InfiniteHorizon()

func FirstHorizon:
	inputs:
		horizon1 Horizon (1..1)
		horizon2 Horizon (1..1)
	output:
		result Horizon (1..1)
	
	assign-output result:
		if horizon1->time exists then (
			if horizon2->time exists then (
				if horizon1->time < horizon2->time
				then horizon1
				else horizon2)
			else horizon1)
		else horizon2


enum Zero:
	Zero

func CreateZero:
	output:
		result Contract (1..1)

	assign-output result->zero:
		Zero

type One:
	currency CurrencyEnum (1..1)

func CreateOne:
	inputs:
		currency CurrencyEnum (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->oneCon->currency:
		currency

type Give:
	contract Contract (1..1)

func CreateGive:
	inputs:
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->give->contract:
		contract

type And:
	contract1 Contract (1..1)
	contract2 Contract (1..1)
	// Alternative: contracts Contract (0..*)

func CreateAnd:
	inputs:
		contract1 Contract (1..1)
		contract2 Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->andCon->contract1:
		contract1
	assign-output result->andCon->contract2:
		contract2

type Or:
	contract1 Contract (1..1)
	contract2 Contract (1..1)
	// Alternative: contracts Contract (0..*)

func CreateOr:
	inputs:
		contract1 Contract (1..1)
		contract2 Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->orCon->contract1:
		contract1
	assign-output result->orCon->contract2:
		contract2

type Truncate:
	time date (1..1)
	contract Contract (1..1)

func CreateTruncate:
	inputs:
		time date (1..1)
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->truncate->time:
		time
	assign-output result->truncate->contract:
		contract

type Then:
	contract1 Contract (1..1)
	contract2 Contract (1..1)
	// Alternative: contracts Contract (0..*)

func CreateThen:
	inputs:
		contract1 Contract (1..1)
		contract2 Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->thenCon->contract1:
		contract1
	assign-output result->thenCon->contract2:
		contract2

type Scale:
	scale Observable (1..1)
	contract Contract (1..1)

func CreateScale:
	inputs:
		scale Observable (1..1)
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->scale->scale:
		scale
	assign-output result->scale->contract:
		contract

type Get:
	contract Contract (1..1)

func CreateGet:
	inputs:
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->get->contract:
		contract

type Anytime:
	contract Contract (1..1)

func CreateAnytime:
	inputs:
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result->anytime->contract:
		contract

type Contract:
	zero Zero (0..1)
	oneCon One (0..1)
	give Give (0..1)
	andCon And (0..1)
	orCon Or (0..1)
	truncate Truncate (0..1)
	thenCon Then (0..1)
	scale Scale (0..1)
	get Get (0..1)
	anytime Anytime (0..1)

	condition: one-of


func CreatePerhaps:
	inputs:
		time date (1..1)
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result:
		CreateTruncate(time, CreateOr(contract, CreateZero()))


func CreateEuropeanOption:
	inputs:
		time date (1..1)
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	assign-output result:
		CreateGet(CreatePerhaps(time, contract))


func CreateAmericanOption:
	inputs:
		start date (1..1)
		stop date (1..1)
		contract Contract (1..1)
	output:
		result Contract (1..1)
	
	alias opt: CreateAnytime(CreatePerhaps(stop, contract))
	assign-output result:
		CreateThen(CreateGet(CreateTruncate(start, opt)), opt)


func GetHorizon:
	inputs:
		contract Contract (1..1)
	output:
		result Horizon (1..1)

	assign-output result:
		if contract->zero exists then InfiniteHorizon()
		else if contract->oneCon exists then InfiniteHorizon()
		else if contract->give exists then GetHorizon(contract->give->contract)
		else if contract->andCon exists then LastHorizon(GetHorizon(contract->andCon->contract1), GetHorizon(contract->andCon->contract2))
		else if contract->orCon exists then LastHorizon(GetHorizon(contract->orCon->contract1), GetHorizon(contract->orCon->contract2))
		else if contract->truncate exists then FirstHorizon(CreateHorizon(contract->truncate->time), GetHorizon(contract->truncate->contract))
		else if contract->thenCon exists then LastHorizon(GetHorizon(contract->thenCon->contract1), GetHorizon(contract->thenCon->contract2))
		else if contract->scale exists then GetHorizon(contract->scale->contract)
		else if contract->get exists then GetHorizon(contract->get->contract)
		else if contract->anytime exists then GetHorizon(contract->anytime->contract)



// Start Region DSL

type Point:
	x number (1..1)
	y number (1..1)

func SubstractPoint:
	inputs:
		point1 Point (1..1)
		point2 Point (1..1)
	output:
		result Point (1..1)
	
	assign-output result->x:
		point1->x - point2->x
	assign-output result->y:
		point1->y - point2->y

// Region-DSL 1

type Region1:

type Circle1 extends Region1:
	r number (1..1)

type Outside1 extends Region1:
	reg Region1 (1..1)

type Intersection1 extends Region1:
	regs Region1 (0..*)

type Translated1 extends Region1:
	trans Point (1..1)
	reg Region1 (1..1)

func InRegion1:
	inputs:
		point Point (1..1)
		region Region1 (1..1)
	output:
		result boolean (1..1)

// Notes:
// - resembles an OO language
// - no polymorphism :(
// - it seems that functions like 'InRegion' can only be implemented manually in a specific target language. Rosetta can only
//   generate the API. Even so, assuming the restriction that we may only extend - not edit - the generated code, InRegion cannot be implemented this way: it requires polymorphism, but polymorphism requires adding a method to the `Region` class and all of its subtypes.

// Region-DSL 2

enum RegionTypeEnum:
	CircleRegion
	OutsideRegion
	IntersectionRegion
	TranslatedRegion

type RegionAttributes:
	r number (0..1)
	reg Region2 (0..1)
	trans Point (0..1)
	reg1 Region2 (0..1)
	reg2 Region2 (0..1)

type Region2:
	regType RegionTypeEnum (1..1)
	attrs RegionAttributes (1..1)

	condition RegionHasRightAttributes:
		if RegionTypeEnum->CircleRegion = regType
		then attrs->r only exists // a circle has a radius
		else if RegionTypeEnum->OutsideRegion = regType
		then attrs->reg only exists
		else if RegionTypeEnum->IntersectionRegion = regType
		then attrs->reg1 exists and attrs->reg2 exists and attrs->r is absent and attrs->reg is absent and attrs->trans is absent
		else if RegionTypeEnum->TranslatedRegion = regType
		then attrs->reg exists and attrs->trans exists and attrs->r is absent and attrs->reg1 is absent and attrs->reg2 is absent

func InRegion2:
	inputs:
		point Point (1..1)
		region Region2 (1..1)
	output:
		result boolean (1..1)
	
	assign-output result:
		if RegionTypeEnum->CircleRegion = region->regType
		then point->x * point->x + point->y * point->y <= region->attrs->r * region->attrs->r
		else if RegionTypeEnum->OutsideRegion = region->regType
		then InRegion2(point, region->attrs->reg) = False
		else if RegionTypeEnum->IntersectionRegion = region->regType
		then InRegion2(point, region->attrs->reg1) and InRegion2(point, region->attrs->reg2)
		else if RegionTypeEnum->TranslatedRegion = region->regType
		then InRegion2(SubstractPoint(point, region->attrs->trans), region->attrs->reg)

// Notes:
// - Adding new regions is cumbersome. It requires:
//   * Adding a field to `RegionTypeEnum`
//   * Adding the required attributes to `RegionAttributes`
//   * Adding a condition in `Region2` to enforce (only) the right attributes are present
//   * Adding an `else if ... then` in the assignment of `InRegion2`
//   Compare this to Haskell: adding a new region only requires a new constructor and an implementation for `inRegion`. In this case, the compiler will also complain if you forget to extend the definition of `inRegion` with the new pattern, in contrast to Rosetta.
// - For the attributes of the intersection region, there are two choices: either it has a list of regions `regs (0..*)`, or it has exactly two regions `reg1 (1..1)` and `reg2 (1..1)`. I chose the latter because the former does not allow a concrete implementation for `InRegion2`, as Rosetta does not have loops for the moment. An alternative is to use a helper function to process a list in some way and implement it in the target language.

// Region-DSL 3

type Circle3:
	r number (1..1)
type Outside3:
	reg Region3 (1..1)
type Intersection3:
	reg1 Region3 (1..1)
	reg2 Region3 (1..1)
type Translated3:
	trans Point (1..1)
	reg Region3 (1..1)

type Region3:
	circle Circle3 (0..1)
	outside Outside3 (0..1)
	intersection Intersection3 (0..1)
	translated Translated3 (0..1)

	condition: one-of

func InRegion3:
	inputs:
		point Point (1..1)
		region Region3 (1..1)
	output:
		result boolean (1..1)
	
	assign-output result:
		if region->circle exists
		then point->x*point->x + point->y*point->y <= region->circle->r*region->circle->r
		else if region->outside exists
		then False = InRegion3(point, region->outside->reg)
		else if region->intersection exists
		then InRegion3(point, region->intersection->reg1) and InRegion3(point, region->intersection->reg2)
		else if region->translated exists
		then InRegion3(SubstractPoint(point, region->translated->trans), region->translated->reg)

// Notes:
// - Adding new regions is a bit less cumbersome. It requires:
//   * Adding a type representing the new region, which contains its attributes.
//   * Adding a field to `Region3` (i.e. extending the union-type `Region3` to also contain the new region type)
//   * Adding an `else if ... then` in the assignment of `InRegion3`
// Q: how does Rosetta handle partial implementation? (e.g. what happens if you forget to add a `else if` to `InRegion.`?)
//  -> it will return null, but will this be caught somehow during validation? The result should never be `null` as the cardinality is set to (1..1).

/****** End of DSL research ******/
